\hypertarget{__hac__vec__monoid_8h}{}\section{\+\_\+hac\+\_\+vec\+\_\+monoid.\+h File Reference}
\label{__hac__vec__monoid_8h}\index{\+\_\+hac\+\_\+vec\+\_\+monoid.\+h@{\+\_\+hac\+\_\+vec\+\_\+monoid.\+h}}
\subsection*{Macros}
\begin{DoxyCompactItemize}
\item 
\#define \hyperlink{__hac__vec__monoid_8h_aa2e2c0aca4da54ef297c118557103ca5}{H\+A\+C\+\_\+\+V\+E\+C\+\_\+\+I\+S\+\_\+\+E\+M\+P\+T\+Y}(base\+\_\+t,  vec)~(!(vec)-\/$>$n)
\begin{DoxyCompactList}\small\item\em Checks if a vector is empty. \end{DoxyCompactList}\item 
\#define \hyperlink{__hac__vec__monoid_8h_a738bb1ebb065ae7dce7df8662bc5d4c8}{H\+A\+C\+\_\+\+V\+E\+C\+\_\+\+E\+M\+P\+T\+Y}(base\+\_\+t)~((\hyperlink{hac__vec_8h_a476a2bba23a3cb1050514473aa3551cc}{H\+A\+C\+\_\+\+V\+E\+C\+\_\+\+T}(base\+\_\+t))\{0\})
\begin{DoxyCompactList}\small\item\em A macro that expands to an empty vector of a type. n and m are 0 and a is N\+U\+L\+L. \end{DoxyCompactList}\item 
\#define \hyperlink{__hac__vec__monoid_8h_aa5ae7f5b0925a3ff96742f5bacd54564}{H\+A\+C\+\_\+\+V\+E\+C\+\_\+\+C\+O\+M\+B\+I\+N\+E}(base\+\_\+t,  veca,  vecb)
\begin{DoxyCompactList}\small\item\em Combines two vectors to make a new vector. Creates a new vector using \hyperlink{__hac__vec__base_8h_a98395dcc138fb0b0957ca8d8acc0dab0}{H\+A\+C\+\_\+\+V\+E\+C\+\_\+\+N\+E\+W(base\+\_\+t, size)} with room for all of the elements in veca and vecb and copies their values into it with memcpy(). Does not deep copy the values whatsoever. \end{DoxyCompactList}\item 
\#define \hyperlink{__hac__vec__monoid_8h_a8f04f6f112bd731aeb77f105df7da55c}{H\+A\+C\+\_\+\+V\+E\+C\+\_\+\+A\+U\+G\+M\+E\+N\+T}(base\+\_\+t,  veca,  vecb)
\begin{DoxyCompactList}\small\item\em Adds one vector onto the end of another. Extends veca using realloc and copies the values in vecb into it with memcpy(). Does not deep copy the values whatsoever. \end{DoxyCompactList}\item 
\#define \hyperlink{__hac__vec__monoid_8h_a43ab11f1fc41f183c93c667b157ef166}{H\+A\+C\+\_\+\+V\+E\+C\+\_\+\+A\+L\+L}(base\+\_\+t,  vec,  expr)
\begin{DoxyCompactList}\small\item\em Tests if a condition applies to all elements of a vector. Reads values from left to right and stops early if one does not meet the condition. \end{DoxyCompactList}\item 
\#define \hyperlink{__hac__vec__monoid_8h_a7daeda5d24e09c192c98f2816e1c46c4}{H\+A\+C\+\_\+\+V\+E\+C\+\_\+\+A\+N\+Y}(base\+\_\+t,  vec,  expr)
\begin{DoxyCompactList}\small\item\em Tests if a condition applies to any element in a vector. Reads values from left to right and stops early if one meets the condition. \end{DoxyCompactList}\item 
\#define \hyperlink{__hac__vec__monoid_8h_a1766bb3009f2840c33ff8856d0bad6af}{H\+A\+C\+\_\+\+V\+E\+C\+\_\+\+C\+O\+N\+T\+A\+I\+N\+S}(base\+\_\+t,  vec,  elem,  comp)~\hyperlink{__hac__vec__monoid_8h_a7daeda5d24e09c192c98f2816e1c46c4}{H\+A\+C\+\_\+\+V\+E\+C\+\_\+\+A\+N\+Y}(base\+\_\+t, vec, (\{base\+\_\+t e1 = elem; base\+\_\+t e2 = e; !(\{comp\});\}))
\begin{DoxyCompactList}\small\item\em Tests if a value contains a value. Reads values from left to right and stops early if one matches. Note that this is O(n) time and if you want to do a lot of checks like this you should look into using a different data structure. \end{DoxyCompactList}\end{DoxyCompactItemize}


\subsection{Macro Definition Documentation}
\hypertarget{__hac__vec__monoid_8h_a43ab11f1fc41f183c93c667b157ef166}{}\index{\+\_\+hac\+\_\+vec\+\_\+monoid.\+h@{\+\_\+hac\+\_\+vec\+\_\+monoid.\+h}!H\+A\+C\+\_\+\+V\+E\+C\+\_\+\+A\+L\+L@{H\+A\+C\+\_\+\+V\+E\+C\+\_\+\+A\+L\+L}}
\index{H\+A\+C\+\_\+\+V\+E\+C\+\_\+\+A\+L\+L@{H\+A\+C\+\_\+\+V\+E\+C\+\_\+\+A\+L\+L}!\+\_\+hac\+\_\+vec\+\_\+monoid.\+h@{\+\_\+hac\+\_\+vec\+\_\+monoid.\+h}}
\subsubsection[{H\+A\+C\+\_\+\+V\+E\+C\+\_\+\+A\+L\+L}]{\setlength{\rightskip}{0pt plus 5cm}\#define H\+A\+C\+\_\+\+V\+E\+C\+\_\+\+A\+L\+L(
\begin{DoxyParamCaption}
\item[{}]{base\+\_\+t, }
\item[{}]{vec, }
\item[{}]{expr}
\end{DoxyParamCaption}
)}\label{__hac__vec__monoid_8h_a43ab11f1fc41f183c93c667b157ef166}
{\bfseries Value\+:}
\begin{DoxyCode}
(\{                              \(\backslash\)
    const \hyperlink{hac__vec_8h_a476a2bba23a3cb1050514473aa3551cc}{HAC\_VEC\_T}(base\_t) *\_vec = (vec);                             \(\backslash\)
    int \_r = 1;                                                        \(\backslash\)
    base\_t e;                                                          \(\backslash\)
    for(\textcolor{keywordtype}{size\_t} \_i = 0; \_r && \_i < \_vec->n; ++\_i)\{                      \(\backslash\)
        e = \_vec->a[\_i];                                               \(\backslash\)
        \_r = \_r && (\{expr;\});                                          \(\backslash\)
    \}                                                                  \(\backslash\)
    \_r;                                                                \(\backslash\)
\})
\end{DoxyCode}


Tests if a condition applies to all elements of a vector. Reads values from left to right and stops early if one does not meet the condition. 


\begin{DoxyParams}{Parameters}
{\em base\+\_\+t} & the base type. \\
\hline
{\em vec} & a pointer to the vector. \\
\hline
{\em expr} & an expression containing e (the current element), evaluating to 1 if true and 0 if false. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
1 if the condition is 1 for all elements of the vector, 0 otherwise. 
\end{DoxyReturn}
\hypertarget{__hac__vec__monoid_8h_a7daeda5d24e09c192c98f2816e1c46c4}{}\index{\+\_\+hac\+\_\+vec\+\_\+monoid.\+h@{\+\_\+hac\+\_\+vec\+\_\+monoid.\+h}!H\+A\+C\+\_\+\+V\+E\+C\+\_\+\+A\+N\+Y@{H\+A\+C\+\_\+\+V\+E\+C\+\_\+\+A\+N\+Y}}
\index{H\+A\+C\+\_\+\+V\+E\+C\+\_\+\+A\+N\+Y@{H\+A\+C\+\_\+\+V\+E\+C\+\_\+\+A\+N\+Y}!\+\_\+hac\+\_\+vec\+\_\+monoid.\+h@{\+\_\+hac\+\_\+vec\+\_\+monoid.\+h}}
\subsubsection[{H\+A\+C\+\_\+\+V\+E\+C\+\_\+\+A\+N\+Y}]{\setlength{\rightskip}{0pt plus 5cm}\#define H\+A\+C\+\_\+\+V\+E\+C\+\_\+\+A\+N\+Y(
\begin{DoxyParamCaption}
\item[{}]{base\+\_\+t, }
\item[{}]{vec, }
\item[{}]{expr}
\end{DoxyParamCaption}
)}\label{__hac__vec__monoid_8h_a7daeda5d24e09c192c98f2816e1c46c4}
{\bfseries Value\+:}
\begin{DoxyCode}
(\{                              \(\backslash\)
    const \hyperlink{hac__vec_8h_a476a2bba23a3cb1050514473aa3551cc}{HAC\_VEC\_T}(base\_t) *\_vec = (vec);                             \(\backslash\)
    int \_r = 0;                                                        \(\backslash\)
    base\_t e;                                                          \(\backslash\)
    for(\textcolor{keywordtype}{size\_t} \_i = 0; (!\_r) && \_i < \_vec->n; ++\_i)\{                   \(\backslash\)
        e = \_vec->a[\_i];                                               \(\backslash\)
        \_r = \_r || (\{expr;\});                                          \(\backslash\)
    \}                                                                  \(\backslash\)
    \_r;                                                                \(\backslash\)
\})
\end{DoxyCode}


Tests if a condition applies to any element in a vector. Reads values from left to right and stops early if one meets the condition. 


\begin{DoxyParams}{Parameters}
{\em base\+\_\+t} & the base type. \\
\hline
{\em vec} & a pointer to the vector. \\
\hline
{\em expr} & an expression containing e (the current element), evaluating to 1 if true and 0 if false. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
1 if the condition is 1 for any element in the sequence, 0 otherwise. 
\end{DoxyReturn}
\hypertarget{__hac__vec__monoid_8h_a8f04f6f112bd731aeb77f105df7da55c}{}\index{\+\_\+hac\+\_\+vec\+\_\+monoid.\+h@{\+\_\+hac\+\_\+vec\+\_\+monoid.\+h}!H\+A\+C\+\_\+\+V\+E\+C\+\_\+\+A\+U\+G\+M\+E\+N\+T@{H\+A\+C\+\_\+\+V\+E\+C\+\_\+\+A\+U\+G\+M\+E\+N\+T}}
\index{H\+A\+C\+\_\+\+V\+E\+C\+\_\+\+A\+U\+G\+M\+E\+N\+T@{H\+A\+C\+\_\+\+V\+E\+C\+\_\+\+A\+U\+G\+M\+E\+N\+T}!\+\_\+hac\+\_\+vec\+\_\+monoid.\+h@{\+\_\+hac\+\_\+vec\+\_\+monoid.\+h}}
\subsubsection[{H\+A\+C\+\_\+\+V\+E\+C\+\_\+\+A\+U\+G\+M\+E\+N\+T}]{\setlength{\rightskip}{0pt plus 5cm}\#define H\+A\+C\+\_\+\+V\+E\+C\+\_\+\+A\+U\+G\+M\+E\+N\+T(
\begin{DoxyParamCaption}
\item[{}]{base\+\_\+t, }
\item[{}]{veca, }
\item[{}]{vecb}
\end{DoxyParamCaption}
)}\label{__hac__vec__monoid_8h_a8f04f6f112bd731aeb77f105df7da55c}
{\bfseries Value\+:}
\begin{DoxyCode}
(\{                         \hyperlink{hac__vec_8h_a476a2bba23a3cb1050514473aa3551cc}{\(\backslash\)}
\hyperlink{hac__vec_8h_a476a2bba23a3cb1050514473aa3551cc}{    HAC\_VEC\_T}(base\_t) *\_a = (veca), *\_b = (vecb);                      \(\backslash\)
    base\_t *\_tmp = realloc(\_a->a, (\_a->n + \_b->n)*\textcolor{keyword}{sizeof}(base\_t));     \(\backslash\)
    if(\_tmp)\{                                                          \(\backslash\)
        \_a->a = \_tmp;                                                  \(\backslash\)
        \_a->m = (\_a->n + \_b->n);                                       \(\backslash\)
        memcpy(\_a->a + \_a->n, \_b->a, \_b->n*\textcolor{keyword}{sizeof}(base\_t));            \(\backslash\)
        \_a->n = \_a->m;                                                 \(\backslash\)
    \}                                                                  \(\backslash\)
    !!\_tmp;                                                            \(\backslash\)
\})
\end{DoxyCode}


Adds one vector onto the end of another. Extends veca using realloc and copies the values in vecb into it with memcpy(). Does not deep copy the values whatsoever. 


\begin{DoxyParams}{Parameters}
{\em base\+\_\+t} & the base type. \\
\hline
{\em veca} & a pointer to the first vector. \\
\hline
{\em vecb} & a pointer to the second vector. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
1 on success or 0 on allocation failure. 
\end{DoxyReturn}
\hypertarget{__hac__vec__monoid_8h_aa5ae7f5b0925a3ff96742f5bacd54564}{}\index{\+\_\+hac\+\_\+vec\+\_\+monoid.\+h@{\+\_\+hac\+\_\+vec\+\_\+monoid.\+h}!H\+A\+C\+\_\+\+V\+E\+C\+\_\+\+C\+O\+M\+B\+I\+N\+E@{H\+A\+C\+\_\+\+V\+E\+C\+\_\+\+C\+O\+M\+B\+I\+N\+E}}
\index{H\+A\+C\+\_\+\+V\+E\+C\+\_\+\+C\+O\+M\+B\+I\+N\+E@{H\+A\+C\+\_\+\+V\+E\+C\+\_\+\+C\+O\+M\+B\+I\+N\+E}!\+\_\+hac\+\_\+vec\+\_\+monoid.\+h@{\+\_\+hac\+\_\+vec\+\_\+monoid.\+h}}
\subsubsection[{H\+A\+C\+\_\+\+V\+E\+C\+\_\+\+C\+O\+M\+B\+I\+N\+E}]{\setlength{\rightskip}{0pt plus 5cm}\#define H\+A\+C\+\_\+\+V\+E\+C\+\_\+\+C\+O\+M\+B\+I\+N\+E(
\begin{DoxyParamCaption}
\item[{}]{base\+\_\+t, }
\item[{}]{veca, }
\item[{}]{vecb}
\end{DoxyParamCaption}
)}\label{__hac__vec__monoid_8h_aa5ae7f5b0925a3ff96742f5bacd54564}
{\bfseries Value\+:}
\begin{DoxyCode}
(\{                         \(\backslash\)
    const \hyperlink{hac__vec_8h_a476a2bba23a3cb1050514473aa3551cc}{HAC\_VEC\_T}(base\_t) *\_a = (veca), *\_b = (vecb);                
      \hyperlink{hac__vec_8h_a476a2bba23a3cb1050514473aa3551cc}{\(\backslash\)}
\hyperlink{hac__vec_8h_a476a2bba23a3cb1050514473aa3551cc}{    HAC\_VEC\_T}(basse\_t) \_c = \_\_HAC\_VEC\_NEW(base\_t, \_a->n + \_b->n);      \(\backslash\)
    if(\_c.a)\{                                                          \(\backslash\)
        memcpy(\_c.a, \_a->a, \_a->n*\textcolor{keyword}{sizeof}(base\_t));                     \(\backslash\)
        memcpy(\_c.a + \_a->n, \_b->a, \_b->n*\textcolor{keyword}{sizeof}(base\_t));             \(\backslash\)
        \_c.n = \_c.m;                                                   \(\backslash\)
    \}                                                                  \(\backslash\)
    \_c;                                                                \(\backslash\)
\})
\end{DoxyCode}


Combines two vectors to make a new vector. Creates a new vector using \hyperlink{__hac__vec__base_8h_a98395dcc138fb0b0957ca8d8acc0dab0}{H\+A\+C\+\_\+\+V\+E\+C\+\_\+\+N\+E\+W(base\+\_\+t, size)} with room for all of the elements in veca and vecb and copies their values into it with memcpy(). Does not deep copy the values whatsoever. 


\begin{DoxyParams}{Parameters}
{\em base\+\_\+t} & the base type. \\
\hline
{\em veca} & a pointer to the first vector. \\
\hline
{\em vecb} & a pointer to the second vector. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
a combination of the two vector. 
\end{DoxyReturn}
\hypertarget{__hac__vec__monoid_8h_a1766bb3009f2840c33ff8856d0bad6af}{}\index{\+\_\+hac\+\_\+vec\+\_\+monoid.\+h@{\+\_\+hac\+\_\+vec\+\_\+monoid.\+h}!H\+A\+C\+\_\+\+V\+E\+C\+\_\+\+C\+O\+N\+T\+A\+I\+N\+S@{H\+A\+C\+\_\+\+V\+E\+C\+\_\+\+C\+O\+N\+T\+A\+I\+N\+S}}
\index{H\+A\+C\+\_\+\+V\+E\+C\+\_\+\+C\+O\+N\+T\+A\+I\+N\+S@{H\+A\+C\+\_\+\+V\+E\+C\+\_\+\+C\+O\+N\+T\+A\+I\+N\+S}!\+\_\+hac\+\_\+vec\+\_\+monoid.\+h@{\+\_\+hac\+\_\+vec\+\_\+monoid.\+h}}
\subsubsection[{H\+A\+C\+\_\+\+V\+E\+C\+\_\+\+C\+O\+N\+T\+A\+I\+N\+S}]{\setlength{\rightskip}{0pt plus 5cm}\#define H\+A\+C\+\_\+\+V\+E\+C\+\_\+\+C\+O\+N\+T\+A\+I\+N\+S(
\begin{DoxyParamCaption}
\item[{}]{base\+\_\+t, }
\item[{}]{vec, }
\item[{}]{elem, }
\item[{}]{comp}
\end{DoxyParamCaption}
)~{\bf H\+A\+C\+\_\+\+V\+E\+C\+\_\+\+A\+N\+Y}(base\+\_\+t, vec, (\{base\+\_\+t e1 = elem; base\+\_\+t e2 = e; !(\{comp\});\}))}\label{__hac__vec__monoid_8h_a1766bb3009f2840c33ff8856d0bad6af}


Tests if a value contains a value. Reads values from left to right and stops early if one matches. Note that this is O(n) time and if you want to do a lot of checks like this you should look into using a different data structure. 


\begin{DoxyParams}{Parameters}
{\em base\+\_\+t} & the base type. \\
\hline
{\em vec} & a pointer to the vector. \\
\hline
{\em elem} & the value to check for in the vector. \\
\hline
{\em comp} & an expression containing e1 and e2 (the two elements to be compared) and returning 0 if they are equal. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
1 if elem is in vec, 0 otherwise. 
\end{DoxyReturn}
\hypertarget{__hac__vec__monoid_8h_a738bb1ebb065ae7dce7df8662bc5d4c8}{}\index{\+\_\+hac\+\_\+vec\+\_\+monoid.\+h@{\+\_\+hac\+\_\+vec\+\_\+monoid.\+h}!H\+A\+C\+\_\+\+V\+E\+C\+\_\+\+E\+M\+P\+T\+Y@{H\+A\+C\+\_\+\+V\+E\+C\+\_\+\+E\+M\+P\+T\+Y}}
\index{H\+A\+C\+\_\+\+V\+E\+C\+\_\+\+E\+M\+P\+T\+Y@{H\+A\+C\+\_\+\+V\+E\+C\+\_\+\+E\+M\+P\+T\+Y}!\+\_\+hac\+\_\+vec\+\_\+monoid.\+h@{\+\_\+hac\+\_\+vec\+\_\+monoid.\+h}}
\subsubsection[{H\+A\+C\+\_\+\+V\+E\+C\+\_\+\+E\+M\+P\+T\+Y}]{\setlength{\rightskip}{0pt plus 5cm}\#define H\+A\+C\+\_\+\+V\+E\+C\+\_\+\+E\+M\+P\+T\+Y(
\begin{DoxyParamCaption}
\item[{}]{base\+\_\+t}
\end{DoxyParamCaption}
)~(({\bf H\+A\+C\+\_\+\+V\+E\+C\+\_\+\+T}(base\+\_\+t))\{0\})}\label{__hac__vec__monoid_8h_a738bb1ebb065ae7dce7df8662bc5d4c8}


A macro that expands to an empty vector of a type. n and m are 0 and a is N\+U\+L\+L. 


\begin{DoxyParams}{Parameters}
{\em base\+\_\+t} & the base type. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
an empty vector for base\+\_\+t. 
\end{DoxyReturn}
\hypertarget{__hac__vec__monoid_8h_aa2e2c0aca4da54ef297c118557103ca5}{}\index{\+\_\+hac\+\_\+vec\+\_\+monoid.\+h@{\+\_\+hac\+\_\+vec\+\_\+monoid.\+h}!H\+A\+C\+\_\+\+V\+E\+C\+\_\+\+I\+S\+\_\+\+E\+M\+P\+T\+Y@{H\+A\+C\+\_\+\+V\+E\+C\+\_\+\+I\+S\+\_\+\+E\+M\+P\+T\+Y}}
\index{H\+A\+C\+\_\+\+V\+E\+C\+\_\+\+I\+S\+\_\+\+E\+M\+P\+T\+Y@{H\+A\+C\+\_\+\+V\+E\+C\+\_\+\+I\+S\+\_\+\+E\+M\+P\+T\+Y}!\+\_\+hac\+\_\+vec\+\_\+monoid.\+h@{\+\_\+hac\+\_\+vec\+\_\+monoid.\+h}}
\subsubsection[{H\+A\+C\+\_\+\+V\+E\+C\+\_\+\+I\+S\+\_\+\+E\+M\+P\+T\+Y}]{\setlength{\rightskip}{0pt plus 5cm}\#define H\+A\+C\+\_\+\+V\+E\+C\+\_\+\+I\+S\+\_\+\+E\+M\+P\+T\+Y(
\begin{DoxyParamCaption}
\item[{}]{base\+\_\+t, }
\item[{}]{vec}
\end{DoxyParamCaption}
)~(!(vec)-\/$>$n)}\label{__hac__vec__monoid_8h_aa2e2c0aca4da54ef297c118557103ca5}


Checks if a vector is empty. 


\begin{DoxyParams}{Parameters}
{\em base\+\_\+t} & the base type. \\
\hline
{\em vec} & a pointer to the vector. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
1 if the vector is empty, 0 otherwise. 
\end{DoxyReturn}
