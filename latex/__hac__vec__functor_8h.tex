\hypertarget{__hac__vec__functor_8h}{}\section{\+\_\+hac\+\_\+vec\+\_\+functor.\+h File Reference}
\label{__hac__vec__functor_8h}\index{\+\_\+hac\+\_\+vec\+\_\+functor.\+h@{\+\_\+hac\+\_\+vec\+\_\+functor.\+h}}
\subsection*{Macros}
\begin{DoxyCompactItemize}
\item 
\#define \hyperlink{__hac__vec__functor_8h_ae9d6665508fb6985700e04e6b42cefc8}{H\+A\+C\+\_\+\+V\+E\+C\+\_\+\+F\+O\+R\+E\+A\+C\+H\+P}(base\+\_\+t,  vec,  expr)
\begin{DoxyCompactList}\small\item\em Applies an expression to each value in a vector by pointer. Note the values are accessed left to right. \end{DoxyCompactList}\item 
\#define \hyperlink{__hac__vec__functor_8h_accabc1e7ec4aec6d2e060b58ae94cb36}{H\+A\+C\+\_\+\+V\+E\+C\+\_\+\+M\+A\+P}(base\+\_\+t,  vec,  expr)
\begin{DoxyCompactList}\small\item\em Creates a new vector by applying an expression to each value in a vector. Note the values are processed left to right. \end{DoxyCompactList}\end{DoxyCompactItemize}


\subsection{Macro Definition Documentation}
\hypertarget{__hac__vec__functor_8h_ae9d6665508fb6985700e04e6b42cefc8}{}\index{\+\_\+hac\+\_\+vec\+\_\+functor.\+h@{\+\_\+hac\+\_\+vec\+\_\+functor.\+h}!H\+A\+C\+\_\+\+V\+E\+C\+\_\+\+F\+O\+R\+E\+A\+C\+H\+P@{H\+A\+C\+\_\+\+V\+E\+C\+\_\+\+F\+O\+R\+E\+A\+C\+H\+P}}
\index{H\+A\+C\+\_\+\+V\+E\+C\+\_\+\+F\+O\+R\+E\+A\+C\+H\+P@{H\+A\+C\+\_\+\+V\+E\+C\+\_\+\+F\+O\+R\+E\+A\+C\+H\+P}!\+\_\+hac\+\_\+vec\+\_\+functor.\+h@{\+\_\+hac\+\_\+vec\+\_\+functor.\+h}}
\subsubsection[{H\+A\+C\+\_\+\+V\+E\+C\+\_\+\+F\+O\+R\+E\+A\+C\+H\+P}]{\setlength{\rightskip}{0pt plus 5cm}\#define H\+A\+C\+\_\+\+V\+E\+C\+\_\+\+F\+O\+R\+E\+A\+C\+H\+P(
\begin{DoxyParamCaption}
\item[{}]{base\+\_\+t, }
\item[{}]{vec, }
\item[{}]{expr}
\end{DoxyParamCaption}
)}\label{__hac__vec__functor_8h_ae9d6665508fb6985700e04e6b42cefc8}
{\bfseries Value\+:}
\begin{DoxyCode}
(\{                         \hyperlink{hac__vec_8h_a476a2bba23a3cb1050514473aa3551cc}{\(\backslash\)}
\hyperlink{hac__vec_8h_a476a2bba23a3cb1050514473aa3551cc}{    HAC\_VEC\_T}(base\_t) *\_vec = (vec);                                   \(\backslash\)
    base\_t *e;                                                         \(\backslash\)
    for(\textcolor{keywordtype}{size\_t} \_i = 0; \_i < \_vec->n; ++\_i)\{                            \(\backslash\)
        e = &\_vec->a[\_i];                                              \(\backslash\)
        \{expr;\}                                                        \(\backslash\)
    \}                                                                  \hyperlink{hac__util_8h_a967927e80dbd5c8582df04345c4c181c}{\(\backslash\)}
\hyperlink{hac__util_8h_a967927e80dbd5c8582df04345c4c181c}{    returnvoid};                                                        \(\backslash\)
\})
\end{DoxyCode}


Applies an expression to each value in a vector by pointer. Note the values are accessed left to right. 


\begin{DoxyParams}{Parameters}
{\em base\+\_\+t} & the base type. \\
\hline
{\em vec} & a pointer to the vector. \\
\hline
{\em expr} & an expression containing e (a pointer to the current element). \\
\hline
\end{DoxyParams}
\hypertarget{__hac__vec__functor_8h_accabc1e7ec4aec6d2e060b58ae94cb36}{}\index{\+\_\+hac\+\_\+vec\+\_\+functor.\+h@{\+\_\+hac\+\_\+vec\+\_\+functor.\+h}!H\+A\+C\+\_\+\+V\+E\+C\+\_\+\+M\+A\+P@{H\+A\+C\+\_\+\+V\+E\+C\+\_\+\+M\+A\+P}}
\index{H\+A\+C\+\_\+\+V\+E\+C\+\_\+\+M\+A\+P@{H\+A\+C\+\_\+\+V\+E\+C\+\_\+\+M\+A\+P}!\+\_\+hac\+\_\+vec\+\_\+functor.\+h@{\+\_\+hac\+\_\+vec\+\_\+functor.\+h}}
\subsubsection[{H\+A\+C\+\_\+\+V\+E\+C\+\_\+\+M\+A\+P}]{\setlength{\rightskip}{0pt plus 5cm}\#define H\+A\+C\+\_\+\+V\+E\+C\+\_\+\+M\+A\+P(
\begin{DoxyParamCaption}
\item[{}]{base\+\_\+t, }
\item[{}]{vec, }
\item[{}]{expr}
\end{DoxyParamCaption}
)}\label{__hac__vec__functor_8h_accabc1e7ec4aec6d2e060b58ae94cb36}
{\bfseries Value\+:}
\begin{DoxyCode}
(\{                              \(\backslash\)
    const \hyperlink{hac__vec_8h_a476a2bba23a3cb1050514473aa3551cc}{HAC\_VEC\_T}(base\_t) *\_vec = (vec);                             
      \hyperlink{hac__vec_8h_a476a2bba23a3cb1050514473aa3551cc}{\(\backslash\)}
\hyperlink{hac__vec_8h_a476a2bba23a3cb1050514473aa3551cc}{    HAC\_VEC\_T}(base\_t) \_ret = \_\_HAC\_VEC\_NEW(base\_t, \_vec->n);           \(\backslash\)
    if(\_ret.a)\{                                                        \(\backslash\)
        base\_t e;                                                      \(\backslash\)
        for(\textcolor{keywordtype}{size\_t} \_i = 0; \_i < \_vec->n; ++\_i)\{                        \(\backslash\)
            e = \_vec->a[\_i];                                           \(\backslash\)
            \_ret.a[\_i] = (\{expr;\});                                    \(\backslash\)
        \}                                                              \(\backslash\)
    \}                                                                  \(\backslash\)
    \_ret;                                                              \(\backslash\)
\})
\end{DoxyCode}


Creates a new vector by applying an expression to each value in a vector. Note the values are processed left to right. 


\begin{DoxyParams}{Parameters}
{\em base\+\_\+t} & the base type. \\
\hline
{\em vec} & a pointer to the vector being mapped over. \\
\hline
{\em expr} & an expression containing e (the current element). \\
\hline
\end{DoxyParams}
